- Each references has its own lifetimes, which is the scope of "life" or when it will be dropped.
	- Ex. 
	"""
	let a = String::new("deez nuts"); //Lifetime 'a
	let b = String::new("hahahahah"); //Lifetime 'b
	let c = get_longest(a.as_str(),b.as_str());
	
	
	fn get_longest(a: &str,b: &str) -> &str {
		if a.len() > b.len() {
			a
		}else {
			b
		}
	}
	"""
		- in This example, it wouldn't compile because a has a different lifetime than b.
- When using lifetime annotations `fn name<'n T>(param: &'n T,param2: &'n T) ->  &'n T {....` you imply that the return value will have the same lifetime as the parameter with the shortest lifetime
- Same thing for structs
- lifetime rules
	1. Each parameter that is a reference gets its own lifetime parameter
	2. If there is exactly one input lifetime parameter, that lifetime is asigned to all output lifetime parameters
	3. If there are multiple input lifetime parameters, but one ofthem is `&self` or `&mut self` the lifetime of self is assigned to all output lifetime parameters
- `'static` is a lifetime outside the bounds of main
